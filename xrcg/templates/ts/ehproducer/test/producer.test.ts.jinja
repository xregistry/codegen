{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "util.jinja.include" as util -%}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import { EventHubProducerClient } from '@azure/event-hubs';
import { GenericContainer, StartedTestContainer, Wait } from 'testcontainers';
import { AzuriteContainer, StartedAzuriteContainer } from '@testcontainers/azurite';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = cloudEvents.usesCloudEvents(root) %}

import { {% for messagegroupid, messagegroup in messagegroups.items() -%}{%- set class_name = (messagegroupid | pascal | strip_namespace) + "Producer" %}{{ class_name }}{% if not loop.last %}, {% endif %}{% endfor %} } from '../src';
{%- if uses_cloudevents_message %}
import { CloudEvent } from 'cloudevents';
{%- endif %}

// Import data types (need to compile data project first: cd ../{{ data_project_name }} && npm install && npm run build)
// NOTE: In real usage, the data project should be a proper npm package dependency
import * as {{ data_project_name }} from '../../{{ data_project_name }}/dist/index.js';

const EMULATOR_CONFIG = `{
  "UserConfig": {
    "NamespaceConfig": [
      {
        "Type": "EventHub",
        "Name": "emulatorNs1",
        "Entities": [
          {
            "Name": "eh1",
            "PartitionCount": "2",
            "ConsumerGroups": [
              {
                "Name": "cg1"
              }
            ]
          }
        ]
      }
    ],
    "LoggingConfig": {
      "Type": "File"
    }
  }
}`;

jest.setTimeout(180000); // 3 minutes for container setup

{%- for messagegroupid, messagegroup in messagegroups.items() %}
{%- set pascal_group_name = messagegroupid | pascal %}
{%- set class_name = (pascal_group_name | strip_namespace) + "Producer" %}
{%- set test_class_name = (project_name | strip_dots | pascal) + (pascal_group_name | strip_dots) + "Tests" %}

describe('{{ test_class_name }}', () => {
    let azuriteContainer: StartedAzuriteContainer;
    let eventHubsEmulatorContainer: StartedTestContainer;
    let emulatorConfigPath: string;
    let eventHubConnectionString: string;
    
    beforeAll(async () => {
        // Create temporary config file for Event Hubs emulator
        emulatorConfigPath = path.join(os.tmpdir(), `emulator-config-${Date.now()}.json`);
        fs.writeFileSync(emulatorConfigPath, EMULATOR_CONFIG);
        
        // Start Azurite container (blob+table storage for Event Hubs checkpoints and metadata)
        // Note: Azurite and Event Hubs emulator need to communicate, but for testing purposes
        // we can use the default network and host.docker.internal or container IPs
        azuriteContainer = await new AzuriteContainer('mcr.microsoft.com/azure-storage/azurite:latest')
            .start();
        
        const azuriteHost = azuriteContainer.getHost();
        const azuriteBlobPort = azuriteContainer.getMappedPort(10000);
        
        // Start Event Hubs emulator container
        // The emulator needs to access Azurite for blob and metadata storage
        eventHubsEmulatorContainer = await new GenericContainer('mcr.microsoft.com/azure-messaging/eventhubs-emulator:latest')
            .withCopyFilesToContainer([{
                source: emulatorConfigPath,
                target: '/Eventhubs_Emulator/ConfigFiles/Config.json'
            }])
            .withExposedPorts(5672)
            .withEnvironment({
                'BLOB_SERVER': `${azuriteHost}:${azuriteBlobPort}`,
                'METADATA_SERVER': `${azuriteHost}:${azuriteBlobPort}`,
                'ACCEPT_EULA': 'Y'
            })
            .withWaitStrategy(Wait.forLogMessage(/.*Emulator is launching with config.*/))
            .withStartupTimeout(180000) // 3 minutes
            .start();
        
        // Build Event Hubs connection string
        eventHubConnectionString = 'Endpoint=sb://localhost;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=SAS_KEY_VALUE;UseDevelopmentEmulator=true;EntityPath=eh1;';
    }, 180000); // 3 minutes timeout for setup
    
    afterAll(async () => {
        if (eventHubsEmulatorContainer) {
            await eventHubsEmulatorContainer.stop();
        }
        if (azuriteContainer) {
            await azuriteContainer.stop();
        }
        if (emulatorConfigPath && fs.existsSync(emulatorConfigPath)) {
            fs.unlinkSync(emulatorConfigPath);
        }
    });

    {%- set message_list = messagegroup.messages.items() | list %}
    {%- for messageid, message in message_list[:3] %}
    {%- set messagename = messageid | strip_namespace | pascal %}
    {%- set body_type = util.body_type(data_project_name, root, message) %}
    {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
    {%- if isCloudEvent %}
    {%- set uriargs = cloudEvents.DeclareUriTemplateArguments(message) %}
    {%- endif %}
    
    test('should send {{ messagename }} messages', async () => {
        const producerClient = new EventHubProducerClient(eventHubConnectionString);
        const producer = new {{ class_name }}(producerClient);
        
        try {
            // Send 5 messages to test proper message handling
            for (let i = 0; i < 5; i++) {
                const testData = { test: 'data', iteration: i } as any;
                await producer.send{{ messagename }}(testData{%- if uriargs -%}
                {%- for arg in uriargs.split(',') if arg.strip() -%}
                , 'test'
                {%- endfor -%}
                {%- endif %});
            }
            
            // Test passes if all sends succeed without throwing
            expect(true).toBe(true);
        } finally {
            await producer.close();
        }
    }, 30000); // 30 second timeout per test
    
    test('should send {{ messagename }} batch', async () => {
        const producerClient = new EventHubProducerClient(eventHubConnectionString);
        const producer = new {{ class_name }}(producerClient);
        
        try {
            // Create batch of test data
            const testDataBatch = Array.from({ length: 10 }, (_, i) => ({ 
                test: 'batch-data', 
                index: i 
            } as any));
            
            await producer.send{{ messagename }}Batch(testDataBatch{%- if uriargs -%}
            {%- for arg in uriargs.split(',') if arg.strip() -%}
            , 'test'
            {%- endfor -%}
            {%- endif %});
            
            // Test passes if batch send succeeds without throwing
            expect(true).toBe(true);
        } finally {
            await producer.close();
        }
    }, 30000); // 30 second timeout per test
    {%- endfor %}
});
{%- endfor %}
