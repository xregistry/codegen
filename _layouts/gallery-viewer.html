<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ page.title }} | {{ site.title }} Gallery</title>
  <meta name="description" content="{{ page.description | default: site.description }}">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="{{ page.url | absolute_url }}">
  <meta property="og:title" content="{{ page.title }} | {{ site.title }} Gallery">
  <meta property="og:description" content="{{ page.description | default: site.description }}">
  <meta property="og:image" content="https://github.com/cncf/artwork/blob/main/projects/xregistry/stacked/color/xregistry-stacked-color.png?raw=true">
  <meta property="og:image:width" content="500">
  <meta property="og:image:height" content="293">
  <meta property="og:site_name" content="xRegistry Codegen">
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="{{ page.url | absolute_url }}">
  <meta name="twitter:title" content="{{ page.title }} | {{ site.title }} Gallery">
  <meta name="twitter:description" content="{{ page.description | default: site.description }}">
  <meta name="twitter:image" content="https://github.com/cncf/artwork/blob/main/projects/xregistry/stacked/color/xregistry-stacked-color.png?raw=true">
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="https://github.com/cncf/artwork/raw/main/projects/xregistry/icon/color/xregistry-icon-color.svg">
  
  <!-- Fonts - Noto Sans like Avrotize -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  
  <!-- Devicons for language icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/devicon.min.css">
  
  <!-- Prism.js for syntax highlighting - Light theme for light background -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
  
  <!-- Custom styles -->
  <link rel="stylesheet" href="{{ '/assets/css/style.css' | relative_url }}">
  <link rel="stylesheet" href="{{ '/assets/css/gallery.css' | relative_url }}">
  
  <style>
    body {
      font-family: 'Noto Sans', sans-serif;
    }
  </style>
</head>
<body class="gallery-page gallery-viewer-page">
  <!-- Compact header -->
  <header class="site-header compact">
    <div class="container">
      <nav class="header-nav">
        <a href="{{ '/' | relative_url }}" class="logo">
          <img src="https://github.com/cncf/artwork/raw/main/projects/xregistry/horizontal/color-whitetext/xregistry-horizontal-color-whitetext.svg" alt="xRegistry" class="logo-img">
          <span class="logo-text">Codegen</span>
        </a>
        <ul class="nav-links">
          <li><a href="{{ '/' | relative_url }}">Home</a></li>
          <li><a href="{{ '/gallery/' | relative_url }}" class="active">Gallery</a></li>
          <li><a href="https://github.com/xregistry/codegen" target="_blank" rel="noopener">
            <i class="devicon-github-original"></i>
          </a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- Gallery viewer page wrapper -->
  <div class="gallery-viewer-wrapper">
    <!-- Header with back button and title -->
    <div class="gallery-header">
      <div class="gallery-header-content">
        <a href="{{ '/gallery/' | relative_url }}" class="btn btn-outline btn-back">‚Üê Back</a>
        <div class="gallery-header-text">
          <h1>{{ page.title }}</h1>
          <p>{{ page.description | default: page.definition_name | append: " with " | append: page.schema_format | append: " schema ‚Üí " | append: page.language | append: " " | append: page.protocol | append: " " | append: page.role }}</p>
          <div class="gallery-header-command">
            <code>{{ page.command }}</code>
            <button class="copy-command-btn" title="Copy command" onclick="navigator.clipboard.writeText('{{ page.command }}'); this.classList.add('copied'); setTimeout(() => this.classList.remove('copied'), 2000);">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Three-panel viewer -->
    <div class="gallery-viewer" id="galleryViewer">
      <!-- Source Panel -->
      <div class="gallery-panel source-panel" id="sourcePanel" data-panel="source">
        <div class="panel-collapse-handle" data-target="source" title="Expand Source">
          <span class="collapse-label">üìÑ Source</span>
        </div>
        <div class="panel-main">
          <div class="panel-header">
            <span>üìÑ Source: {{ page.definition_name }}</span>
            <button class="panel-collapse-btn" data-target="source" title="Collapse panel">‚óÄ</button>
          </div>
          <div class="panel-content" id="sourceContent">
            <pre class="line-numbers"><code class="language-json" id="source-code">{{ page.definition_content | escape }}</code></pre>
          </div>
        </div>
      </div>
      
      <!-- Resize Handle 1 -->
      <div class="resize-handle" data-resize="source-tree" title="Drag to resize">
        <div class="resize-grip"></div>
      </div>
      
      <!-- File Tree Panel -->
      <div class="gallery-panel tree-panel" id="treePanel" data-panel="tree">
        <div class="panel-collapse-handle" data-target="tree" title="Expand Output Files">
          <span class="collapse-label">üìÅ Files</span>
        </div>
        <div class="panel-main">
          <div class="panel-header">
            <button class="panel-collapse-btn" data-target="tree" title="Collapse panel">‚óÄ</button>
            <span>üìÅ Output Files</span>
            <button class="panel-collapse-btn" data-target="tree" title="Collapse panel">‚ñ∂</button>
          </div>
          <div class="panel-content">
            <div class="file-tree" id="fileTree">
              {{ page.file_tree_html }}
            </div>
          </div>
        </div>
      </div>
      
      <!-- Resize Handle 2 -->
      <div class="resize-handle" data-resize="tree-output" title="Drag to resize">
        <div class="resize-grip"></div>
      </div>
      
      <!-- Output Panel -->
      <div class="gallery-panel output-panel" id="outputPanel" data-panel="output">
        <div class="panel-collapse-handle" data-target="output" title="Expand Output">
          <span class="collapse-label">üìÑ Output</span>
        </div>
        <div class="panel-main">
          <div class="panel-header">
            <button class="panel-collapse-btn" data-target="output" title="Collapse panel">‚óÄ</button>
            <span id="outputFileName">üìÑ Select a file to view</span>
            <div class="panel-actions">
              <button class="copy-btn" id="copy-btn" title="Copy code">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                  <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
                Copy
              </button>
              <a href="{{ page.zip_url }}" class="download-btn" download>
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                  <polyline points="7 10 12 15 17 10"></polyline>
                  <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                Download ZIP
              </a>
            </div>
          </div>
          <div class="panel-content" id="outputContent">
            <pre class="line-numbers"><code id="preview-code" class="language-plaintext">Select a file from the tree to view its contents.</code></pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- File data for JavaScript -->
  <script type="application/json" id="gallery-data">
    {{ page.files_json }}
  </script>

  <!-- Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
  (function() {
    // Panel collapse/expand functionality (adapted from avrotize)
    const viewer = document.getElementById('galleryViewer');
    const panels = {
      source: document.getElementById('sourcePanel'),
      tree: document.getElementById('treePanel'),
      output: document.getElementById('outputPanel')
    };
    const handles = {
      sourceTree: document.querySelector('[data-resize="source-tree"]'),
      treeOutput: document.querySelector('[data-resize="tree-output"]')
    };
    
    function getCollapsedCount() {
      return Object.values(panels).filter(p => p.classList.contains('collapsed')).length;
    }
    
    function isCollapsed(panelId) {
      return panels[panelId] && panels[panelId].classList.contains('collapsed');
    }
    
    function togglePanel(panelId) {
      const panel = panels[panelId];
      if (!panel) return;
      
      const wasCollapsed = panel.classList.contains('collapsed');
      
      if (wasCollapsed) {
        // Expanding - always allowed
        panel.classList.remove('collapsed');
      } else {
        // Collapsing - only if less than 2 are already collapsed
        if (getCollapsedCount() < 2) {
          panel.classList.add('collapsed');
        }
      }
      
      updateLayout();
      saveState();
    }
    
    function updateLayout() {
      const sourceCollapsed = isCollapsed('source');
      const treeCollapsed = isCollapsed('tree');
      const outputCollapsed = isCollapsed('output');
      
      // Update resize handle states
      if (handles.sourceTree) {
        const disabled = sourceCollapsed || (treeCollapsed && outputCollapsed);
        handles.sourceTree.classList.toggle('disabled', disabled);
        handles.sourceTree.classList.toggle('spans-collapsed', treeCollapsed && !sourceCollapsed && !outputCollapsed);
      }
      if (handles.treeOutput) {
        const disabled = outputCollapsed || treeCollapsed;
        handles.treeOutput.classList.toggle('disabled', disabled);
      }
      
      // Only reset flex values for panels that were just expanded (no flex set) or are collapsed
      // Don't reset if they already have a pixel-based flex value
      if (sourceCollapsed) {
        panels.source.style.flex = '';
      }
      if (treeCollapsed) {
        panels.tree.style.flex = '';
      }
      if (outputCollapsed) {
        panels.output.style.flex = '';
      }
      
      // Handle different collapsed combinations - set flex for remaining panels
      if (sourceCollapsed && !treeCollapsed && !outputCollapsed) {
        if (!panels.tree.style.flex || !panels.tree.style.flex.includes('px')) {
          panels.tree.style.flex = '0 0 280px';
        }
        if (!panels.output.style.flex || !panels.output.style.flex.includes('px')) {
          panels.output.style.flex = '1 1 auto';
        }
      } else if (treeCollapsed && !sourceCollapsed && !outputCollapsed) {
        // When tree is collapsed, source and output should share space
        if (!panels.source.style.flex.includes('px') || !panels.output.style.flex.includes('px')) {
          panels.source.style.flex = '1 1 50%';
          panels.output.style.flex = '1 1 50%';
        }
      } else if (outputCollapsed && !sourceCollapsed && !treeCollapsed) {
        if (!panels.source.style.flex || !panels.source.style.flex.includes('px')) {
          panels.source.style.flex = '1 1 auto';
        }
        if (!panels.tree.style.flex || !panels.tree.style.flex.includes('px')) {
          panels.tree.style.flex = '0 0 280px';
        }
      } else if (sourceCollapsed && treeCollapsed) {
        panels.output.style.flex = '1 1 auto';
      } else if (sourceCollapsed && outputCollapsed) {
        panels.tree.style.flex = '1 1 auto';
        panels.tree.style.maxWidth = 'none';
      } else if (treeCollapsed && outputCollapsed) {
        panels.source.style.flex = '1 1 auto';
      }
    }
    
    // Collapse button click handlers
    document.querySelectorAll('.panel-collapse-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        togglePanel(btn.dataset.target);
      });
    });
    
    // Collapsed handle click to expand
    document.querySelectorAll('.panel-collapse-handle').forEach(handle => {
      handle.addEventListener('click', () => {
        togglePanel(handle.dataset.target);
      });
    });
    
    // Resize functionality
    let isResizing = false;
    let currentHandle = null;
    let startPos = 0;
    let startSizes = {};
    
    // Detect if we're in vertical (stacked) layout mode
    function isVerticalLayout() {
      return window.innerWidth <= 900;
    }
    
    document.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('mousedown', (e) => {
        if (handle.classList.contains('disabled')) return;
        
        isResizing = true;
        currentHandle = handle;
        const vertical = isVerticalLayout();
        startPos = vertical ? e.clientY : e.clientX;
        
        const resizeType = handle.dataset.resize;
        const treeCollapsed = isCollapsed('tree');
        
        if (resizeType === 'source-tree') {
          startSizes.source = vertical ? panels.source.offsetHeight : panels.source.offsetWidth;
          if (treeCollapsed) {
            startSizes.output = vertical ? panels.output.offsetHeight : panels.output.offsetWidth;
          } else {
            startSizes.tree = vertical ? panels.tree.offsetHeight : panels.tree.offsetWidth;
          }
        } else if (resizeType === 'tree-output') {
          startSizes.tree = vertical ? panels.tree.offsetHeight : panels.tree.offsetWidth;
          startSizes.output = vertical ? panels.output.offsetHeight : panels.output.offsetWidth;
        }
        
        viewer.classList.add('resizing');
        handle.classList.add('active');
        
        e.preventDefault();
      });
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;
      
      const vertical = isVerticalLayout();
      const currentPos = vertical ? e.clientY : e.clientX;
      const delta = currentPos - startPos;
      const resizeType = currentHandle.dataset.resize;
      const treeCollapsed = isCollapsed('tree');
      
      // Min sizes - use smaller values for vertical layout
      const minPanelSize = vertical ? 100 : 200;
      const minTreeSize = vertical ? 80 : 180;
      const maxTreeSize = vertical ? 400 : 500;
      
      if (resizeType === 'source-tree') {
        if (treeCollapsed) {
          const newSourceSize = Math.max(minPanelSize, startSizes.source + delta);
          const newOutputSize = Math.max(minPanelSize, startSizes.output - delta);
          if (vertical) {
            panels.source.style.flex = `0 0 ${newSourceSize}px`;
            panels.output.style.flex = `0 0 ${newOutputSize}px`;
          } else {
            panels.source.style.flex = `1 0 ${newSourceSize}px`;
            panels.output.style.flex = `1 0 ${newOutputSize}px`;
          }
        } else {
          const newSourceSize = Math.max(minPanelSize, startSizes.source + delta);
          const newTreeSize = Math.max(minTreeSize, Math.min(maxTreeSize, startSizes.tree - delta));
          if (vertical) {
            panels.source.style.flex = `0 0 ${newSourceSize}px`;
            panels.tree.style.flex = `0 0 ${newTreeSize}px`;
          } else {
            panels.source.style.flex = `1 0 ${newSourceSize}px`;
            panels.tree.style.flex = `0 0 ${newTreeSize}px`;
          }
        }
      } else if (resizeType === 'tree-output') {
        const newTreeSize = Math.max(minTreeSize, Math.min(maxTreeSize, startSizes.tree + delta));
        const newOutputSize = Math.max(minPanelSize, startSizes.output - delta);
        if (vertical) {
          panels.tree.style.flex = `0 0 ${newTreeSize}px`;
          panels.output.style.flex = `0 0 ${newOutputSize}px`;
        } else {
          panels.tree.style.flex = `0 0 ${newTreeSize}px`;
          panels.output.style.flex = `1 0 ${newOutputSize}px`;
        }
      }
    });
    
    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        viewer.classList.remove('resizing');
        if (currentHandle) {
          currentHandle.classList.remove('active');
        }
        currentHandle = null;
        saveState();
      }
    });
    
    // State persistence
    function saveState() {
      const state = {
        collapsed: {
          source: isCollapsed('source'),
          tree: isCollapsed('tree'),
          output: isCollapsed('output')
        },
        widths: {
          source: panels.source.style.flex,
          tree: panels.tree.style.flex,
          output: panels.output.style.flex
        }
      };
      try {
        localStorage.setItem('galleryViewerState', JSON.stringify(state));
      } catch (e) {}
    }
    
    function loadState() {
      try {
        const state = JSON.parse(localStorage.getItem('galleryViewerState'));
        if (state) {
          let collapsedCount = 0;
          Object.entries(state.collapsed || {}).forEach(([id, collapsed]) => {
            if (collapsed && collapsedCount < 2 && panels[id]) {
              panels[id].classList.add('collapsed');
              collapsedCount++;
            }
          });
          // Restore saved widths - ensure source/output have flex-grow:1
          if (state.widths) {
            if (state.widths.source && panels.source && !isCollapsed('source')) {
              // Convert old 0 0 Xpx format to 1 0 Xpx for source panel
              const sourceMatch = state.widths.source.match(/(\d+)px/);
              if (sourceMatch) {
                panels.source.style.flex = `1 0 ${sourceMatch[1]}px`;
              } else {
                panels.source.style.flex = state.widths.source;
              }
            }
            if (state.widths.tree && panels.tree && !isCollapsed('tree')) {
              panels.tree.style.flex = state.widths.tree;
            }
            if (state.widths.output && panels.output && !isCollapsed('output')) {
              // Convert old 0 0 Xpx format to 1 0 Xpx for output panel
              const outputMatch = state.widths.output.match(/(\d+)px/);
              if (outputMatch) {
                panels.output.style.flex = `1 0 ${outputMatch[1]}px`;
              } else {
                panels.output.style.flex = state.widths.output;
              }
            }
          }
          updateLayout();
        }
      } catch (e) {}
    }
    
    // Lock panel widths to pixels after initial layout to prevent content-based resizing
    // Source and output panels use flex-grow: 1 to fill available space
    // Tree panel stays fixed width
    function lockPanelWidths() {
      if (!isCollapsed('source') && !panels.source.style.flex.includes('px')) {
        panels.source.style.flex = `1 0 ${panels.source.offsetWidth}px`;
      }
      if (!isCollapsed('tree') && !panels.tree.style.flex.includes('px')) {
        panels.tree.style.flex = `0 0 ${panels.tree.offsetWidth}px`;
      }
      if (!isCollapsed('output') && !panels.output.style.flex.includes('px')) {
        panels.output.style.flex = `1 0 ${panels.output.offsetWidth}px`;
      }
      saveState();
    }
    
    // Initialize panel state
    loadState();
    updateLayout();
    // Lock widths after a short delay to allow CSS to compute initial sizes
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        lockPanelWidths();
      });
    });
  })();
  </script>

  <script>
  document.addEventListener('DOMContentLoaded', function() {
    // Parse file data
    let filesData = [];
    try {
      const dataEl = document.getElementById('gallery-data');
      if (dataEl && dataEl.textContent.trim()) {
        const parsed = JSON.parse(dataEl.textContent);
        // Handle both {files: [...]} and [...] formats with type checking
        if (Array.isArray(parsed)) {
          filesData = parsed;
        } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.files)) {
          filesData = parsed.files;
        }
      }
    } catch (e) {
      console.error('Failed to parse gallery data:', e);
    }
    
    const fileTree = document.getElementById('fileTree');
    const previewCode = document.getElementById('preview-code');
    const outputFileName = document.getElementById('outputFileName');
    const copyBtn = document.getElementById('copy-btn');
    
    // File tree click handling
    fileTree.addEventListener('click', function(e) {
      const treeItem = e.target.closest('.file-tree-item');
      if (!treeItem) return;
      
      const filePath = treeItem.dataset.path;
      
      // Handle folder toggle
      if (treeItem.classList.contains('folder')) {
        const folderContents = treeItem.parentElement.querySelector('.folder-contents');
        const toggleIcon = treeItem.querySelector('.folder-toggle');
        if (folderContents) {
          folderContents.classList.toggle('collapsed');
          if (toggleIcon) {
            toggleIcon.classList.toggle('collapsed');
          }
        }
        return;
      }
      
      // Handle file selection
      if (filePath) {
        // Update active state
        fileTree.querySelectorAll('.file-tree-item').forEach(item => item.classList.remove('active'));
        treeItem.classList.add('active');
        
        // Update URL hash
        updateUrlHash(filePath);
        
        // Find file content
        const file = filesData.find(f => f.path === filePath);
        if (file) {
          outputFileName.textContent = 'üìÑ ' + filePath.split('/').pop();
          
          // Determine language for syntax highlighting
          const ext = filePath.split('.').pop().toLowerCase();
          const langMap = {
            'py': 'python',
            'cs': 'csharp',
            'java': 'java',
            'ts': 'typescript',
            'js': 'javascript',
            'go': 'go',
            'json': 'json',
            'yaml': 'yaml',
            'yml': 'yaml',
            'xml': 'xml',
            'md': 'markdown',
            'proto': 'protobuf',
            'avsc': 'json',
            'sh': 'bash',
            'bat': 'batch',
            'ps1': 'powershell',
            'toml': 'toml',
            'csproj': 'xml',
            'sln': 'plaintext'
          };
          
          const lang = langMap[ext] || 'plaintext';
          previewCode.className = `language-${lang}`;
          previewCode.textContent = file.content;
          
          // Re-highlight
          Prism.highlightElement(previewCode);
        }
      }
    });
    
    // Copy button
    copyBtn.addEventListener('click', function() {
      const code = previewCode.textContent;
      navigator.clipboard.writeText(code).then(() => {
        const originalText = copyBtn.innerHTML;
        copyBtn.classList.add('copied');
        copyBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg> Copied!';
        setTimeout(() => {
          copyBtn.classList.remove('copied');
          copyBtn.innerHTML = originalText;
        }, 2000);
      });
    });
    
    // Highlight source code
    const sourceCode = document.getElementById('source-code');
    if (sourceCode) {
      Prism.highlightElement(sourceCode);
    }
    
    // URL Hash Navigation Functions
    function updateUrlHash(filePath) {
      if (filePath) {
        const newHash = '#file=' + encodeURIComponent(filePath);
        if (window.location.hash !== newHash) {
          history.replaceState(null, '', newHash);
        }
      }
    }
    
    function getFilePathFromHash() {
      const hash = window.location.hash;
      if (hash && hash.startsWith('#file=')) {
        return decodeURIComponent(hash.substring(6));
      }
      return null;
    }
    
    function expandParentFolders(path) {
      const parts = path.split('/');
      let currentPath = '';
      for (let i = 0; i < parts.length - 1; i++) {
        currentPath += (i > 0 ? '/' : '') + parts[i];
        const folderItem = fileTree.querySelector('.file-tree-item.folder[data-path="' + currentPath + '"]');
        if (folderItem) {
          const folderContents = folderItem.parentElement.querySelector('.folder-contents');
          const toggleIcon = folderItem.querySelector('.folder-toggle');
          if (folderContents && folderContents.classList.contains('collapsed')) {
            folderContents.classList.remove('collapsed');
            if (toggleIcon) {
              toggleIcon.classList.remove('collapsed');
            }
          }
        }
      }
    }
    
    function selectFileByPath(path) {
      // Expand parent folders first
      expandParentFolders(path);
      
      // Find and click the file
      const fileItem = fileTree.querySelector('.file-tree-item[data-path="' + path + '"]');
      if (fileItem) {
        fileItem.click();
        return true;
      }
      return false;
    }
    
    function loadDefaultFile() {
      // Try to load README.md first
      const readmeItem = fileTree.querySelector('.file-tree-item[data-path="README.md"]');
      if (readmeItem) {
        readmeItem.click();
        return;
      }
      
      // Fall back to first file
      const firstFile = fileTree.querySelector('.file-tree-item:not(.folder)');
      if (firstFile) {
        firstFile.click();
      }
    }
    
    // Check for file path in URL hash on load
    const hashPath = getFilePathFromHash();
    if (hashPath) {
      // Wait a tick for DOM to be ready
      setTimeout(() => {
        if (!selectFileByPath(hashPath)) {
          // Hash path not found, load default
          loadDefaultFile();
        }
      }, 0);
    } else {
      // No hash, load default file
      loadDefaultFile();
    }
  });
  </script>
</body>
</html>
